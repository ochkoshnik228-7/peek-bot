import os
import requests
import time
import threading
from datetime import datetime, timedelta
from flask import Flask, request
import telebot

# --- Настройки ---
TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
PANDASCORE_TOKEN = os.getenv("PANDASCORE_TOKEN")
BASE_URL = "https://api.pandascore.io/csgo/matches/upcoming"

bot = telebot.TeleBot(TELEGRAM_TOKEN)
app = Flask(__name__)

# Данные пользователей {user_id: {"balance": int, "bets": []}}
users = {}

# Получение матчей
def get_upcoming_matches():
    now = datetime.utcnow()
    one_week_later = now + timedelta(days=7)
    headers = {"Authorization": f"Bearer {PANDASCORE_TOKEN}"}
    params = {"per_page": 10, "sort": "begin_at"}
    r = requests.get(BASE_URL, headers=headers, params=params)
    matches = []
    if r.status_code == 200:
        for match in r.json():
            if match["begin_at"]:
                start_time = datetime.fromisoformat(match["begin_at"].replace("Z", "+00:00"))
                if now < start_time <= one_week_later:
                    team1 = match["opponents"][0]["opponent"]["name"]
                    team2 = match["opponents"][1]["opponent"]["name"]
                    odds1 = round(1 + (0.5 * len(team2)), 2)  # Мок коэффициенты
                    odds2 = round(1 + (0.5 * len(team1)), 2)
                    matches.append({
                        "id": match["id"],
                        "team1": team1,
                        "team2": team2,
                        "odds1": odds1,
                        "odds2": odds2
                    })
    return matches

# --- Команды ---
@bot.message_handler(commands=["start"])
def start(message):
    user_id = message.chat.id
    if user_id not in users:
        users[user_id] = {"balance": 10000, "bets": []}
        bot.send_message(user_id, "Добро пожаловать! Вы получили 10000 peek!")
    else:
        bot.send_message(user_id, "Вы уже получили бонус.")
    bot.send_message(user_id, "Доступные команды:\n/matches — список матчей\n/balance — ваш баланс")

@bot.message_handler(commands=["balance"])
def balance(message):
    user_id = message.chat.id
    bal = users.get(user_id, {}).get("balance", 0)
    bot.send_message(user_id, f"Ваш баланс: {bal} peek")

@bot.message_handler(commands=["matches"])
def matches(message):
    upcoming = get_upcoming_matches()
    if not upcoming:
        bot.send_message(message.chat.id, "Нет предстоящих матчей.")
        return
    text = "Предстоящие матчи:\n"
    for i, m in enumerate(upcoming, 1):
        text += f"{i}. {m['team1']} {m['odds1']} VS {m['team2']} {m['odds2']}\n"
    bot.send_message(message.chat.id, text)
    bot.send_message(message.chat.id, "Выберите команду: /command1 или /command2")
    users[message.chat.id]["current_matches"] = upcoming

@bot.message_handler(commands=["command1", "command2"])
def choose_team(message):
    user_id = message.chat.id
    if "current_matches" not in users[user_id]:
        bot.send_message(user_id, "Сначала выберите матч через /matches")
        return
    users[user_id]["chosen_team"] = 1 if message.text == "/command1" else 2
    bot.send_message(user_id, "Сколько peek ставите?")

    bot.register_next_step_handler(message, place_bet)

def place_bet(message):
    user_id = message.chat.id
    try:
        amount = int(message.text)
    except ValueError:
        bot.send_message(user_id, "Введите число!")
        return

    if amount > users[user_id]["balance"]:
        bot.send_message(user_id, "Недостаточно peek!")
        return

    match = users[user_id]["current_matches"][0]  # Берём первый матч из списка
    chosen_team = users[user_id]["chosen_team"]

    odds = match["odds1"] if chosen_team == 1 else match["odds2"]

    users[user_id]["balance"] -= amount
    users[user_id]["bets"].append({
        "match_id": match["id"],
        "team": chosen_team,
        "amount": amount,
        "odds": odds
    })
    bot.send_message(user_id, "Ваша ставка принята!")

# Проверка результатов
def check_results():
    while True:
        time.sleep(60)
        for user_id, data in users.items():
            for bet in data["bets"]:
                url = f"https://api.pandascore.io/csgo/matches/{bet['match_id']}"
                r = requests.get(url, headers={"Authorization": f"Bearer {PANDASCORE_TOKEN}"})
                if r.status_code == 200:
                    match = r.json()
                    if match["status"] == "finished":
                        winner_id = match["winner"]["id"]
                        chosen_team_id = match["opponents"][bet["team"] - 1]["opponent"]["id"]
                        if winner_id == chosen_team_id:
                            win_amount = int(bet["amount"] * bet["odds"])
                            users[user_id]["balance"] += win_amount
                            bot.send_message(user_id, "Ваша ставка зашла!")
                        else:
                            bot.send_message(user_id, "Ваша ставка не зашла :(")
                        data["bets"].remove(bet)

# Запускаем поток проверки результатов
threading.Thread(target=check_results, daemon=True).start()

# Flask вебхук
@app.route(f"/{TELEGRAM_TOKEN}", methods=["POST"])
def webhook():
    json_str = request.get_data().decode("UTF-8")
    update = telebot.types.Update.de_json(json_str)
    bot.process_new_updates([update])
    return "OK", 200

@app.route("/")
def index():
    return "Бот работает!"

if __name__ == "__main__":
    bot.remove_webhook()
    bot.set_webhook(url=f"https://peek-bot.onrender.com/{TELEGRAM_TOKEN}")
    app.run(host="0.0.0.0", port=10000)





