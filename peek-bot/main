import os
import re
import sqlite3
import asyncio
from datetime import datetime
import requests
from bs4 import BeautifulSoup
from fastapi import FastAPI, Request
import uvicorn
from aiogram import Bot, Dispatcher, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

BOT_TOKEN = 8314578862:AAFmgkZTLNaPFQCiDiqCZtUNeTxWK3MghFA
WEBHOOK_BASE = os.getenv("WEBHOOK_URL")
PORT = int(os.getenv("PORT", "8000"))
CHECK_INTERVAL = int(os.getenv("CHECK_INTERVAL", "60"))
START_BALANCE = float(os.getenv("START_BALANCE", "10000"))

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN не задан в переменных окружения")

WEBHOOK_PATH = f"/webhook/{BOT_TOKEN}"
WEBHOOK_FULL = (WEBHOOK_BASE.rstrip("/") if WEBHOOK_BASE else "") + WEBHOOK_PATH if WEBHOOK_BASE else None

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot)
app = FastAPI()

DB = "database.db"
conn = sqlite3.connect(DB, check_same_thread=False)
cur = conn.cursor()
cur.executescript("""
CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY, balance REAL);
CREATE TABLE IF NOT EXISTS bets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    match_id TEXT,
    match_name TEXT,
    match_link TEXT,
    team TEXT,
    amount REAL,
    coef REAL,
    placed_at TEXT,
    status TEXT
);
CREATE TABLE IF NOT EXISTS matches_cache (
    match_id TEXT PRIMARY KEY,
    name TEXT,
    team1 TEXT,
    team2 TEXT,
    start_ts INTEGER,
    coef1 REAL,
    coef2 REAL,
    link TEXT,
    status TEXT
);
""")
conn.commit()

WINLINE_LIST_URL = "https://m.winline.ru/stavki/sport/kibersport"

def fetch_url(url):
    try:
        r = requests.get(url, headers={"User-Agent": "Mozilla/5.0"}, timeout=10)
        r.raise_for_status()
        return r.text
    except:
        return None

def parse_matches_from_winline(html):
    soup = BeautifulSoup(html, "lxml")
    matches = []
    anchors = soup.find_all("a", href=True)
    for a in anchors:
        txt = a.get_text(" ", strip=True)
        parent_text = a.parent.get_text(" ", strip=True) if a.parent else txt
        combined = (txt + " " + parent_text).lower()
        if "counter" not in combined and "counter-strike" not in combined and "counter strike" not in combined:
            continue
        link = a["href"]
        link = link if link.startswith("http") else "https://m.winline.ru" + link
        m = re.search(r"([A-Z0-9\-\.\s]{2,50})\s*[—\-\/]\s*([A-Z0-9\-\.\s]{2,50})", txt)
        if not m:
            m = re.search(r"([A-Za-z0-9\-\.\s]{2,50})\s*[—\-\/]\s*([A-Za-z0-9\-\.\s]{2,50})", parent_text)
        if m:
            team1 = m.group(1).strip()
            team2 = m.group(2).strip()
            name = f"{team1} / {team2}"
        else:
            parts = txt.split("/")
            team1 = parts[0].strip() if parts else txt
            team2 = parts[1].strip() if len(parts) > 1 else ""
            name = f"{team1} / {team2}" if team2 else txt
        coef1 = coef2 = None
        nearby = a.parent.find_all(text=re.compile(r"\d+[\.,]\d+")) if a.parent else []
        nums = []
        for t in nearby:
            s = t.strip().replace(",", ".")
            try:
                nums.append(float(s))
            except:
                pass
        if len(nums) >= 2:
            coef1, coef2 = nums[0], nums[1]
        start_ts = None
        for attr in ("data-time","data-start","data-unix"):
            if a.has_attr(attr):
                try:
                    start_ts = int(a[attr])
                    if start_ts > 1e10:
                        start_ts = start_ts // 1000
                except:
                    start_ts = None
        match_id = re.sub(r"\W+", "_", link)
        matches.append({
            "match_id": match_id,
            "name": name,
            "team1": team1,
            "team2": team2,
            "start_ts": start_ts,
            "coef1": coef1,
            "coef2": coef2,
            "link": link
        })
    uniq = {}
    for m in matches:
        uniq[m["match_id"]] = m
    return list(uniq.values())

def get_cs_matches():
    html = fetch_url(WINLINE_LIST_URL)
    if not html:
        return []
    return parse_matches_from_winline(html)

async def send_matches_list(chat_id):
    matches = get_cs_matches()
    if not matches:
        await bot.send_message(chat_id, "Не удалось найти матчи Counter-Strike.")
        return
    kb = InlineKeyboardMarkup(row_width=1)
    for m in matches:
        start = datetime.utcfromtimestamp(m["start_ts"]).strftime("%Y-%m-%d %H:%M UTC") if m["start_ts"] else "время неизвестно"
        title = f"{m['team1']} / {m['team2']} — {start}"
        kb.add(InlineKeyboardButton(title, callback_data=f"match|{m['match_id']}"))
        cur.execute("""
            INSERT OR REPLACE INTO matches_cache (match_id, name, team1, team2, start_ts, coef1, coef2, link, status)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (m["match_id"], m["name"], m["team1"], m["team2"], m["start_ts"] or 0, m["coef1"] or 0.0, m["coef2"] or 0.0, m["link"], "upcoming"))
    conn.commit()
    await bot.send_message(chat_id, "Выберите матч Counter-Strike:", reply_markup=kb)

user_session = {}

@dp.message_handler(commands=["start"])
async def start_handler(message: types.Message):
    uid = message.from_user.id
    cur.execute("INSERT OR IGNORE INTO users (user_id, balance) VALUES (?, ?)", (uid, START_BALANCE))
    conn.commit()
    await bot.send_message(uid, f"Привет! Твой баланс: {START_BALANCE:.2f} Peek. Отправь /matches чтобы увидеть матчи.")

@dp.message_handler(commands=["matches"])
async def matches_handler(message: types.Message):
    await send_matches_list(message.chat.id)

@dp.callback_query_handler(lambda c: c.data and c.data.startswith("match|"))
async def match_cb(callback: types.CallbackQuery):
    _, match_id = callback.data.split("|",1)
    cur.execute("SELECT name, team1, team2, coef1, coef2, link FROM matches_cache WHERE match_id = ?", (match_id,))
    row = cur.fetchone()
    if not row:
        await callback.message.answer("Информация по матчу недоступна.")
        return
    name, t1, t2, c1, c2, link = row
    kb = InlineKeyboardMarkup(row_width=2)
    kb.add(InlineKeyboardButton(f"{t1} ({c1})", callback_data=f"bet|{match_id}|{t1}|{c1}"),
           InlineKeyboardButton(f"{t2} ({c2})", callback_data=f"bet|{match_id}|{t2}|{c2}"))
    await callback.message.answer(f"{t1} {c1} / {t2} {c2}")
    await callback.message.answer("Выберите команду для ставки:", reply_markup=kb)

@dp.callback_query_handler(lambda c: c.data and c.data.startswith("bet|"))
async def bet_cb(callback: types.CallbackQuery):
    _, match_id, team, coef_str = callback.data.split("|",3)
    coef = float(coef_str) if coef_str and coef_str != "None" else 1.0
    uid = callback.from_user.id
    cur.execute("SELECT balance FROM users WHERE user_id = ?", (uid,))
    row = cur.fetchone()
    balance = row[0] if row else 0.0
    user_session[uid] = {"match_id": match_id, "team": team, "coef": coef}
    await bot.send_message(uid, f"Вы выбрали {team} (коэф {coef}). Введите сумму Peek для ставки (баланс: {balance:.2f}):")

@dp.message_handler()
async def text_handler(message: types.Message):
    uid = message.from_user.id
    if uid not in user_session:
        return
    txt = message.text.strip().replace(",", ".")
    try:
        amount = float(txt)
    except:
        await bot.send_message(uid, "Пожалуйста, введите число.")
        return
    cur.execute("SELECT balance FROM users WHERE user_id = ?", (uid,))
    row = cur.fetchone()
    if not row:
        await bot.send_message(uid, "Пользователь не найден. Отправьте /start")
        return
    balance = row[0]
    if amount <= 0 or amount > balance:
        await bot.send_message(uid, "Неверная сумма.")
        return
    sess = user_session.pop(uid)
    match_id = sess["match_id"]
    team = sess["team"]
    coef = sess["coef"]
    cur.execute("SELECT link, name FROM matches_cache WHERE match_id = ?", (match_id,))
    r = cur.fetchone()
    link = r[0] if r else ""
    name = r[1] if r else ""
    placed_at = datetime.utcnow().isoformat()
    cur.execute("INSERT INTO bets (user_id, match_id, match_name, match_link, team, amount, coef, placed_at, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (uid, match_id, name, link, team, amount, coef, placed_at, "pending"))
    cur.execute("UPDATE users SET balance = balance - ? WHERE user_id = ?", (amount, uid))
    conn.commit()
    await bot.send_message(uid, "Ставка принята. Удачи!")

def parse_winner_from_match_page(html, match):
    if not html:
        return None
    text = BeautifulSoup(html, "lxml").get_text(" ", strip=True).lower()
    for team in (match.get("team1",""), match.get("team2","")):
        if not team:
            continue
        if team.lower() in text:
            if re.search(rf"{re.escape(team.lower())}.{{0,40}}(выигр|победил|победилa|win|winner)", text, re.IGNORECASE):
                return team
    sm = re.search(r"(\d+)\s*[:\-]\s*(\d+)", text)
    if sm:
        a,b = int(sm.group(1)), int(sm.group(2))
        if a> b:
            return match.get("team1")
        if b> a:
            return match.get("team2")
    return None

async def background_checker():
    await asyncio.sleep(5)
    while True:
        try:
            cur.execute("SELECT DISTINCT match_id FROM bets WHERE status = 'pending'")
            rows = cur.fetchall()
            mids = [r[0] for r in rows]
            if not mids:
                await asyncio.sleep(CHECK_INTERVAL)
                continue
            for mid in mids:
                cur.execute("SELECT link, team1, team2, start_ts FROM matches_cache WHERE match_id = ?", (mid,))
                r = cur.fetchone()
                if not r:
                    continue
                link, team1, team2, start_ts = r
                match = {"match_id": mid, "team1": team1, "team2": team2, "link": link, "start_ts": start_ts}
                html = fetch_url(link) if link else None
                winner = parse_winner_from_match_page(html, match)
                if winner:
                    cur.execute("SELECT id, user_id, team, amount, coef FROM bets WHERE match_id = ? AND status = 'pending'", (mid,))
                    bets = cur.fetchall()
                    for bet in bets:
                        bid, uid, team, amount, coef = bet
                        if team == winner:
                            payout = amount * (coef if coef and coef>0 else 1.0)
                            cur.execute("UPDATE users SET balance = balance + ? WHERE user_id = ?", (payout, uid))
                            cur.execute("UPDATE bets SET status = 'won' WHERE id = ?", (bid,))
                            asyncio.create_task(bot.send_message(uid, f"Поздравляем! Вы выиграли {payout:.2f} Peek."))
                        else:
                            cur.execute("UPDATE bets SET status = 'lost' WHERE id = ?", (bid,))
                            asyncio.create_task(bot.send_message(uid, f"Упс... вы проиграли ставку на {team}."))
                    conn.commit()
                else:
                    if start_ts and start_ts < int(datetime.utcnow().timestamp()):
                        cur.execute("UPDATE matches_cache SET status = 'started' WHERE match_id = ?", (mid,))
                        conn.commit()
        except Exception as e:
            print("checker error:", e)
        await asyncio.sleep(CHECK_INTERVAL)

@app.on_event("startup")
async def on_startup():
    if WEBHOOK_FULL:
        await bot.set_webhook(WEBHOOK_FULL)
    asyncio.create_task(background_checker())

@app.on_event("shutdown")
async def on_shutdown():
    try:
        await bot.delete_webhook()
    except:
        pass

@app.post(WEBHOOK_PATH)
async def telegram_webhook(request: Request):
    data = await request.json()
    update = types.Update.to_object(data)
    await dp.process_update(update)
    return {"ok": True}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=PORT)





