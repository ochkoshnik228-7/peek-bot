import os
import json
import logging
from datetime import datetime, timedelta, timezone
from typing import Optional, Tuple, Dict, Any, List

import requests
from telegram import Update
from telegram.ext import (
    Application, CommandHandler, MessageHandler, ContextTypes, filters
)

# ------------------ CONFIG ------------------
TELEGRAM_TOKEN = "8307763623:AAHBWKqlY_Ys8BGojmwNSsFOEpDR-2BxEvo"
PANDASCORE_TOKEN = "c3jff6TYOnQfs1Hmce1qhBIgJRZQmJ9CvW_vuhdx1VbKStUfR9o"

DATA_FILE = "peek_data.json"
BASE_URL = "https://api.pandascore.co"  # (–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è —É–∫–∞–∑—ã–≤–∞–µ—Ç .co)
# --------------------------------------------

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
)
log = logging.getLogger("peek-bot")

WELCOME_BONUS = 10_000
DEFAULT_ODDS = (1.90, 1.90)  # –µ—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã —Ä–µ–∞–ª—å–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã
MAX_MATCHES = 10             # —Å–∫–æ–ª—å–∫–æ –º–∞—Ç—á–µ–π –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤ /matches
CHECK_INTERVAL_SEC = 180     # –∫–∞–∫ —á–∞—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –∏—Å—Ö–æ–¥—ã –º–∞—Ç—á–µ–π

# ---------- –ø—Ä–æ—Å—Ç–µ–π—à–µ–µ JSON-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ ----------
def _load() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            log.exception("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è %s, —Å—Ç–∞—Ä—Ç—É–µ–º —Å –ø—É—Å—Ç–æ–π –ë–î", DATA_FILE)
    return {}

def _save(db: Dict[str, Any]) -> None:
    tmp = DATA_FILE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(db, f, ensure_ascii=False, indent=2)
    os.replace(tmp, DATA_FILE)

DB = _load()
# —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ DB:
# {
#   "<user_id>": {
#       "balance": int,
#       "bonus_claimed": bool,
#       "open_bet": { ... } | null,
#       "selected_match": int | null
#   },
#   "_bets": {
#       "<bet_id>": {
#            "user_id": str,
#            "match_id": int,
#            "team_id": int,
#            "team_name": str,
#            "odds": float,
#            "amount": int,
#            "status": "placed"|"won"|"lost",
#            "placed_at": iso8601
#       }
#   }
# }

def ensure_user(uid: str) -> Dict[str, Any]:
    if uid not in DB:
        DB[uid] = {"balance": 0, "bonus_claimed": False, "open_bet": None, "selected_match": None}
        _save(DB)
    return DB[uid]

def add_bet_record(rec: Dict[str, Any]) -> str:
    DB.setdefault("_bets", {})
    bet_id = f"{rec['user_id']}:{rec['match_id']}:{int(datetime.now(timezone.utc).timestamp())}"
    DB["_bets"][bet_id] = rec
    _save(DB)
    return bet_id

# -------------- PandaScore helpers --------------
def ps_headers() -> Dict[str, str]:
    return {"Authorization": f"Bearer {PANDASCORE_TOKEN}"}

def get_upcoming_cs_matches() -> List[Dict[str, Any]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π CS (CS:GO/CS2) —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º not_started –≤ —Å–ª–µ–¥—É—é—â–∏–µ 7 –¥–Ω–µ–π.
    """
    now = datetime.now(timezone.utc)
    week = now + timedelta(days=7)

    # –í PandaScore –¥–æ —Å–∏—Ö –ø–æ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—É—Ç—å /csgo –¥–ª—è CS2 (—Å–º. –∏—Ö –º–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–æ–∫–∏).
    # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ —Å—Ç–∞—Ç—É—Å—É –∏ –¥–∏–∞–ø–∞–∑–æ–Ω—É –Ω–∞—á–∞–ª–∞.
    params = {
        "filter[status]": "not_started",
        "range[begin_at]": f"{now.isoformat()},{week.isoformat()}",
        "per_page": MAX_MATCHES,
        "sort": "begin_at"
    }
    url = f"{BASE_URL}/csgo/matches"
    r = requests.get(url, headers=ps_headers(), params=params, timeout=20)
    r.raise_for_status()
    return r.json()

def safe_team_pair(match: Dict[str, Any]) -> Optional[Tuple[Dict[str, Any], Dict[str, Any]]]:
    opp = match.get("opponents") or []
    if len(opp) != 2:
        return None
    # opponents[i]["opponent"] -> { "id": int, "name": str }
    t1 = opp[0].get("opponent") or {}
    t2 = opp[1].get("opponent") or {}
    if not t1.get("id") or not t2.get("id"):
        return None
    return t1, t2

def try_get_odds(match_id: int, team1_id: int, team2_id: int) -> Tuple[float, float]:
    """
    –ü—Ä–æ–±—É–µ–º –≤—ã—Ç–∞—â–∏—Ç—å –∫–æ—ç—Ñ-—Ç—ã —É PandaScore (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ –≤ —Ç–∞—Ä–∏—Ñ–µ).
    –í –ø—É–±–ª–∏—á–Ω–æ–π —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–µ odds-—ç–Ω–¥–ø–æ–∏–Ω—Ç –Ω–µ –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω, –ø–æ—ç—Ç–æ–º—É –¥–µ–ª–∞–µ–º
    –Ω–µ—Å–∫–æ–ª—å–∫–æ "—Ä–∞–∑—É–º–Ω—ã—Ö" –ø–æ–ø—ã—Ç–æ–∫ –∏ –ø–∞–¥–∞–µ–º –Ω–∞ –¥–µ—Ñ–æ–ª—Ç.
    """
    candidates = [
        f"{BASE_URL}/csgo/matches/{match_id}/odds",
        f"{BASE_URL}/matches/{match_id}/odds",
    ]
    for url in candidates:
        try:
            r = requests.get(url, headers=ps_headers(), timeout=15)
            if r.status_code == 404:
                continue
            r.raise_for_status()
            data = r.json()
            # –æ–∂–∏–¥–∞–µ–º —Ñ–æ—Ä–º–∞—Ç —Å —Ä—ã–Ω–∫–æ–º "match_winner" –∏ decimal odds
            # –ø–æ–¥–±–∏—Ä–∞–µ–º –ª—É—á—à—É—é –ª–∏–Ω–∏—é (–±–µ—Ä—ë–º –ø–µ—Ä–≤—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ)
            if isinstance(data, list) and data:
                # –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ moneyline / match_winner
                for market in data:
                    lines = market.get("lines") or market.get("markets") or []
                    if isinstance(lines, dict):
                        lines = [lines]
                    for line in lines:
                        sel = line.get("selections") or line.get("outcomes") or []
                        # –∏—â–µ–º –ø–æ team_id
                        o1 = next((s for s in sel if str(s.get("team_id")) == str(team1_id)), None)
                        o2 = next((s for s in sel if str(s.get("team_id")) == str(team2_id)), None)
                        if o1 and o2:
                            od1 = float(o1.get("odds_decimal") or o1.get("odds") or DEFAULT_ODDS[0])
                            od2 = float(o2.get("odds_decimal") or o2.get("odds") or DEFAULT_ODDS[1])
                            # –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ sanity-–ø—Ä–æ–≤–µ—Ä–∫–∏
                            if od1 >= 1.01 and od2 >= 1.01:
                                return round(od1, 2), round(od2, 2)
        except requests.RequestException:
            log.exception("–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ odds %s", url)
        except Exception:
            log.exception("–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç odds %s", url)
    return DEFAULT_ODDS

def get_match(match_id: int) -> Optional[Dict[str, Any]]:
    url = f"{BASE_URL}/matches/{match_id}"
    try:
        r = requests.get(url, headers=ps_headers(), timeout=15)
        r.raise_for_status()
        return r.json()
    except Exception:
        # –∑–∞–ø–∞—Å–Ω–æ–π –ø—É—Ç—å –¥–ª—è csgo
        try:
            url2 = f"{BASE_URL}/csgo/matches/{match_id}"
            r2 = requests.get(url2, headers=ps_headers(), timeout=15)
            r2.raise_for_status()
            return r2.json()
        except Exception:
            log.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–∞—Ç—á %s", match_id)
            return None

# ---------------- Bot command handlers ----------------
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = str(update.effective_user.id)
    user = ensure_user(uid)
    if not user["bonus_claimed"]:
        user["balance"] += WELCOME_BONUS
        user["bonus_claimed"] = True
        _save(DB)
        await update.message.reply_text("–í—ã –ø–æ–ª—É—á–∏–ª–∏ 10 000 peek! ü™ô")
    else:
        await update.message.reply_text("–ë–æ–Ω—É—Å —É–∂–µ –±—ã–ª –ø–æ–ª—É—á–µ–Ω. –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ!")

async def cmd_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = str(update.effective_user.id)
    user = ensure_user(uid)
    await update.message.reply_text(f"–í–∞—à –±–∞–ª–∞–Ω—Å: {user['balance']} peek ü™ô")

def fmt_decimal(x: float) -> str:
    # –í –ø—Ä–∏–º–µ—Ä–µ –∑–∞–ø—è—Ç–∞—è ‚Äî –ø—Ä–∏–≤–µ–¥—ë–º –∫ –Ω–µ–π
    return f"{x:.2f}".replace(".", ",")

async def cmd_matches(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = str(update.effective_user.id)
    ensure_user(uid)

    try:
        matches = get_upcoming_cs_matches()
    except requests.HTTPError as e:
        log.exception("PandaScore HTTP error: %s", e)
        await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π (–æ—à–∏–±–∫–∞ PandaScore). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return
    except Exception:
        log.exception("Unexpected error fetching matches")
        await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return

    view: List[Dict[str, Any]] = []
    lines = []
    idx = 1
    for m in matches:
        pair = safe_team_pair(m)
        if not pair:
            continue
        t1, t2 = pair
        # –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã
        od1, od2 = try_get_odds(m["id"], t1["id"], t2["id"])
        begin_at = m.get("begin_at") or m.get("scheduled_at")
        when = begin_at or ""
        try:
            # –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–∞—Ç—É –∫ –ª–æ–∫–∞–ª—å–Ω–æ–º—É –≤–∏–¥—É –∫–æ—Ä–æ—Ç–∫–æ
            dt = datetime.fromisoformat(when.replace("Z", "+00:00"))
            when_str = dt.strftime("%d.%m %H:%M UTC")
        except Exception:
            when_str = str(when)

        lines.append(f"{idx}. {t1['name']} {fmt_decimal(od1)} VS {t2['name']} {fmt_decimal(od2)}  ‚Äî  {when_str}")
        view.append({
            "idx": idx,
            "match_id": m["id"],
            "team1": {"id": t1["id"], "name": t1["name"], "odds": od1},
            "team2": {"id": t2["id"], "name": t2["name"], "odds": od2},
        })
        idx += 1

    if not view:
        await update.message.reply_text("–ù–µ—Ç –±–ª–∏–∂–∞–π—à–∏—Ö –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –º–∞—Ç—á–µ–π.")
        return

    # —Å–æ—Ö—Ä–∞–Ω–∏–º —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π –≤ user_data —Å–µ—Å—Å–∏–∏
    context.user_data["matches_view"] = view
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á (–æ—Ç–≤–µ—Ç—å—Ç–µ —á–∏—Å–ª–æ–º 1‚Äì{n}), –∑–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /command1 –∏–ª–∏ /command2:\n\n{lst}".format(
            n=len(view), lst="\n".join(lines)
        )
    )

async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –º–∞—Ç—á–∞ –∏ —Å—É–º–º—ã —Å—Ç–∞–≤–∫–∏
    uid = str(update.effective_user.id)
    user = ensure_user(uid)
    text = (update.message.text or "").strip()

    # 1) –≤—ã–±–æ—Ä –º–∞—Ç—á–∞ –Ω–æ–º–µ—Ä–æ–º
    if "matches_view" in context.user_data and context.user_data["matches_view"]:
        if text.isdigit():
            choice = int(text)
            view: List[Dict[str, Any]] = context.user_data["matches_view"]
            picked = next((v for v in view if v["idx"] == choice), None)
            if picked:
                user["selected_match"] = picked["match_id"]
                # —Å–æ—Ö—Ä–∞–Ω–∏–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, —á—Ç–æ–±—ã –ø–æ—Ç–æ–º –Ω–µ –∏—Å–∫–∞—Ç—å
                context.user_data["selected"] = picked
                _save(DB)
                await update.message.reply_text(
                    f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –º–∞—Ç—á #{choice}. –¢–µ–ø–µ—Ä—å –Ω–∞–∂–º–∏—Ç–µ /command1 (–ª–µ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞) –∏–ª–∏ /command2 (–ø—Ä–∞–≤–∞—è)."
                )
                return
        # –µ—Å–ª–∏ –Ω–µ —á–∏—Å–ª–æ ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–∞ —Å—É–º–º—É –Ω–∏–∂–µ (—Å—Ç–∞–≤–∫–∞)
    # 2) –≤–≤–æ–¥ —Å—É–º–º—ã —Å—Ç–∞–≤–∫–∏
    if user.get("open_bet") and "awaiting_amount" in user["open_bet"] and user["open_bet"]["awaiting_amount"]:
        try:
            amount = int(text.replace(" ", ""))
        except ValueError:
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ‚Äî —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏ –≤ peek.")
            return
        if amount <= 0:
            await update.message.reply_text("–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π.")
            return
        if amount > user["balance"]:
            await update.message.reply_text("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ peek!")
            return
        # —Å–ø–∏—Å–∞–Ω–∏–µ –∏ —Ñ–∏–∫—Å–∞—Ü–∏—è —Å—Ç–∞–≤–∫–∏
        sel = user["open_bet"]["selection"]  # dict with team info & odds
        user["balance"] -= amount
        bet_rec = {
            "user_id": uid,
            "match_id": user["open_bet"]["match_id"],
            "team_id": sel["id"],
            "team_name": sel["name"],
            "odds": sel["odds"],
            "amount": amount,
            "status": "placed",
            "placed_at": datetime.now(timezone.utc).isoformat()
        }
        add_bet_record(bet_rec)
        user["open_bet"] = None
        _save(DB)
        await update.message.reply_text("–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞!")
        return

    # –∏–Ω–∞—á–µ –∏–≥–Ω–æ—Ä–∏–º –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
    # (–º–æ–∂–Ω–æ –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã)
    # await update.message.reply_text("–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: /start /matches /balance")

async def _prepare_bet(update: Update, context: ContextTypes.DEFAULT_TYPE, pick_left: bool):
    uid = str(update.effective_user.id)
    user = ensure_user(uid)
    if user["balance"] <= 0:
        await update.message.reply_text("–ù–∞ –±–∞–ª–∞–Ω—Å–µ 0. –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–æ–Ω—É—Å–æ–º —á–µ—Ä–µ–∑ /start (–æ–¥–∏–Ω —Ä–∞–∑) –∏–ª–∏ –∂–¥–∏—Ç–µ –∏—Å—Ö–æ–¥–æ–≤ –ø—Ä–æ—à–ª—ã—Ö —Å—Ç–∞–≤–æ–∫.")
        return

    selected = context.user_data.get("selected")
    if not selected or user.get("selected_match") != selected["match_id"]:
        await update.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –∫–æ–º–∞–Ω–¥–æ–π /matches –∏ –Ω–æ–º–µ—Ä–æ–º –∏–∑ —Å–ø–∏—Å–∫–∞.")
        return

    team = selected["team1"] if pick_left else selected["team2"]
    user["open_bet"] = {
        "match_id": selected["match_id"],
        "selection": {"id": team["id"], "name": team["name"], "odds": float(team["odds"])},
        "awaiting_amount": True
    }
    _save(DB)
    await update.message.reply_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ {team['name']}. –°–∫–æ–ª—å–∫–æ peek —Å—Ç–∞–≤–∏—à—å?")

async def cmd_command1(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _prepare_bet(update, context, pick_left=True)

async def cmd_command2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _prepare_bet(update, context, pick_left=False)

# -------------- Settlement job --------------
def _settle_bet(bet_id: str, bet: Dict[str, Any]) -> Optional[Tuple[str, int]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (message, delta_balance) –µ—Å–ª–∏ –±—ã–ª –∑–∞—Å—á–∏—Ç–∞–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç; –∏–Ω–∞—á–µ None.
    """
    m = get_match(bet["match_id"])
    if not m:
        return None
    status = m.get("status")
    if status != "finished":
        return None
    winner = m.get("winner") or {}
    winner_id = winner.get("id")
    if not winner_id:
        # –∏–Ω–æ–≥–¥–∞ winner –º–æ–∂–µ—Ç –±—ã—Ç—å null –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ ‚Äî –≤ —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–≤–∫—É
        # (–º–æ–∂–Ω–æ –æ–±–æ–∑–Ω–∞—á–∏—Ç—å –∫–∞–∫ push/void). –í–µ—Ä–Ω—ë–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –±–µ–∑ –≤—ã–∏–≥—Ä—ã—à–∞.
        delta = bet["amount"]
        msg = "–ú–∞—Ç—á –æ—Ç–º–µ–Ω—ë–Ω/–±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ ‚Äî —Å—Ç–∞–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞."
        return msg, delta
    if int(winner_id) == int(bet["team_id"]):
        win_amount = int(round(bet["amount"] * float(bet["odds"])))
        delta = win_amount  # –Ω–∞—á–∏—Å–ª—è–µ–º –ø–æ–ª–Ω—ã–π –≤—ã–∏–≥—Ä—ã—à (—Å—Ç–∞–≤–∫–∞ * –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç)
        msg = "–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –∑–∞—à–ª–∞! üéâ"
    else:
        delta = 0  # –±–∞–ª–∞–Ω—Å –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç—Å—è
        msg = "–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –Ω–µ –∑–∞—à–ª–∞ :("
    return msg, delta

async def job_check_bets(context: ContextTypes.DEFAULT_TYPE):
    DB.setdefault("_bets", {})
    changed = False
    for bet_id, bet in list(DB["_bets"].items()):
        if bet.get("status") != "placed":
            continue
        res = _settle_bet(bet_id, bet)
        if not res:
            continue
        msg, delta = res
        uid = bet["user_id"]
        user = ensure_user(uid)
        if delta:
            user["balance"] += delta
        bet["status"] = "won" if delta else "lost"
        changed = True
        try:
            await context.bot.send_message(
                chat_id=int(uid),
                text=msg + (f"\n–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {user['balance']} peek ü™ô" if msg else "")
            )
        except Exception:
            log.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é %s", uid)
    if changed:
        _save(DB)

# -------------------- main --------------------
def main():
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("balance", cmd_balance))
    app.add_handler(CommandHandler("matches", cmd_matches))
    app.add_handler(CommandHandler("command1", cmd_command1))
    app.add_handler(CommandHandler("command2", cmd_command2))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))

    # –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏—Å—Ö–æ–¥—ã
    app.job_queue.run_repeating(job_check_bets, interval=CHECK_INTERVAL_SEC, first=15)

    # --- polling (–ø—Ä–æ—â–µ –≤—Å–µ–≥–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –≥–¥–µ —É–≥–æ–¥–Ω–æ)
    app.run_polling(allowed_updates=Update.ALL_TYPES)

    # –ï—Å–ª–∏ –∑–∞—Ö–æ—á–µ—à—å webhook –Ω–∞ Render (–ø—Ä–∏–º–µ—Ä):
    # BASE = os.environ.get("PUBLIC_URL", "https://peek-bot.onrender.com")
    # PORT = int(os.environ.get("PORT", "8080"))
    # app.run_webhook(
    #     listen="0.0.0.0",
    #     port=PORT,
    #     url_path=TELEGRAM_TOKEN,
    #     webhook_url=f"{BASE}/{TELEGRAM_TOKEN}",
    #     allowed_updates=Update.ALL_TYPES
    # )

if __name__ == "__main__":
    # import uvloop; uvloop.install()  # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
    main()
