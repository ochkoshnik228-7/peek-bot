import os
import re
import sqlite3
import time
import asyncio
from datetime import datetime
import requests
from bs4 import BeautifulSoup
from fastapi import FastAPI, Request
import uvicorn
import json

# ---------------------------
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ (—Ç–æ–∫–µ–Ω –≤—Å—Ç—Ä–æ–µ–Ω)
# ---------------------------
BOT_TOKEN = "8314578862:AAFmgkZTLNaPFQCiDiqCZtUNeTxWK3MghFA"
WEBHOOK_BASE = os.getenv("WEBHOOK_URL")  # —Å—Ç–∞–≤–∏–º –≤ Render: https://your-service.onrender.com
WEBHOOK_PATH = f"/webhook/{BOT_TOKEN}"
WEBHOOK_FULL = (WEBHOOK_BASE.rstrip("/") + WEBHOOK_PATH) if WEBHOOK_BASE else None
TELEGRAM_API = f"https://api.telegram.org/bot{BOT_TOKEN}"

# –ë–î –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
DB_FILE = "peek_bot.db"
START_BALANCE = 10000.0
CHECK_INTERVAL = int(os.getenv("CHECK_INTERVAL", "60"))  # –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
DEFAULT_STAKE = None  # –µ—Å–ª–∏ None ‚Äî –ø—Ä–æ—Å–∏–º –≤–≤–µ—Å—Ç–∏ —Å—É–º–º—É, –∏–Ω–∞—á–µ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—É–º–º–∞

# –°—Å—ã–ª–∫–∞ –º–æ–±–∏–ª—å–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–∞ Winline
WINLINE_URL = "https://m.winline.ru/stavki/sport/kibersport"

app = FastAPI()

# ---------------------------
# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
# ---------------------------
conn = sqlite3.connect(DB_FILE, check_same_thread=False)
cur = conn.cursor()
cur.executescript("""
CREATE TABLE IF NOT EXISTS users (
  user_id INTEGER PRIMARY KEY,
  balance REAL
);
CREATE TABLE IF NOT EXISTS bets (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  match_id TEXT,
  match_name TEXT,
  team TEXT,
  amount REAL,
  coef REAL,
  placed_at TEXT,
  status TEXT
);
CREATE TABLE IF NOT EXISTS matches_cache (
  match_id TEXT PRIMARY KEY,
  name TEXT,
  team1 TEXT,
  team2 TEXT,
  start_ts INTEGER,
  coef1 REAL,
  coef2 REAL,
  link TEXT,
  status TEXT
);
""")
conn.commit()

# in-memory sessions: awaiting amount from user, selected match per user, etc.
user_sessions = {}          # user_id -> {"stage":"await_amount","match_id":..., "team":..., "coef":...}
# keep a small LRU cache? for now DB stores matches_cache

# ---------------------------
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ Telegram
# ---------------------------
def tg_send_message(chat_id: int, text: str, reply_markup: dict = None, parse_mode: str = "HTML"):
    payload = {"chat_id": chat_id, "text": text, "parse_mode": parse_mode}
    if reply_markup:
        payload["reply_markup"] = reply_markup
    try:
        requests.post(f"{TELEGRAM_API}/sendMessage", json=payload, timeout=10)
    except Exception as e:
        print("tg_send_message error:", e, payload)

def tg_answer_callback(callback_id: str, text: str = None):
    payload = {"callback_query_id": callback_id}
    if text:
        payload["text"] = text
    try:
        requests.post(f"{TELEGRAM_API}/answerCallbackQuery", json=payload, timeout=10)
    except Exception as e:
        print("tg_answer_callback error:", e, payload)

# ---------------------------
# –ü–∞—Ä—Å–∏–Ω–≥ Winline ‚Äî –º–∞—Ç—á–∏ CS
# ---------------------------
def fetch(url: str) -> str:
    try:
        r = requests.get(url, headers={"User-Agent":"Mozilla/5.0"}, timeout=10)
        r.raise_for_status()
        return r.text
    except Exception as e:
        print("fetch error", e, url)
        return None

def parse_matches(html: str):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π –≤–∏–¥–∞:
    [{"match_id": str, "name": str, "team1": str, "team2": str, "start_ts": int|None,
      "coef1": float|None, "coef2": float|None, "link": str}, ...]
    """
    soup = BeautifulSoup(html, "lxml")
    out = []

    # –ø–æ–ø—ã—Ç–∫–∏ –Ω–∞–π—Ç–∏ –∫–∞—Ä—Ç–æ—á–∫–∏ –º–∞—Ç—á–µ–π ‚Äî —Ä–∞–∑–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –Ω–∞ —Å–ª—É—á–∞–π —Å–º–µ–Ω—ã –≤–µ—Ä—Å—Ç–∫–∏
    # –æ—Å–Ω–æ–≤–Ω–æ–π –ø–æ–¥—Ö–æ–¥: –Ω–∞–π—Ç–∏ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å–æ–±—ã—Ç–∏—è –∏ —Ç–µ–∫—Å—Ç —Å –∫–æ–º–∞–Ω–¥–∞–º–∏ –∏ —Ä—è–¥–æ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã
    anchors = soup.find_all("a", href=True)
    for a in anchors:
        text = a.get_text(" ", strip=True)
        parent_text = a.parent.get_text(" ", strip=True) if a.parent else ""
        comb = (text + " " + parent_text).lower()
        # —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ Counter-Strike
        if not ("counter" in comb or "counter-strike" in comb or "counter strike" in comb):
            continue

        href = a["href"]
        link = href if href.startswith("http") else "https://m.winline.ru" + href

        # –∏–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—ã
        m = re.search(r"([A-Za-z0-9\-\.\s]{2,60})\s*[‚Äî\-\\/]\s*([A-Za-z0-9\-\.\s]{2,60})", text)
        if not m:
            m = re.search(r"([A-Za-z0-9\-\.\s]{2,60})\s*[‚Äî\-\\/]\s*([A-Za-z0-9\-\.\s]{2,60})", parent_text)
        if m:
            t1 = m.group(1).strip()
            t2 = m.group(2).strip()
            name = f"{t1} / {t2}"
        else:
            parts = text.split("/")
            if len(parts) >= 2:
                t1 = parts[0].strip()
                t2 = parts[1].strip()
                name = f"{t1} / {t2}"
            else:
                continue  # –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ –º–∞—Ç—á

        # –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã ‚Äî –∏—â–µ–º —Ä—è–¥–æ–º —á–∏—Å–ª–∞ 1.23
        coef1 = coef2 = None
        nearby = a.parent.find_all(text=re.compile(r"\d+[\.,]\d+")) if a.parent else []
        nums = []
        for t in nearby:
            s = t.strip().replace(",", ".")
            try:
                nums.append(float(s))
            except:
                pass
        if len(nums) >= 2:
            coef1, coef2 = nums[0], nums[1]

        # –≤—Ä–µ–º—è —Å—Ç–∞—Ä—Ç–∞ ‚Äî –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –≤ –∞—Ç—Ä–∏–±—É—Ç–∞—Ö
        start_ts = None
        for attr in ("data-time","data-start","data-unix","data-ts"):
            if a.has_attr(attr):
                try:
                    v = int(a[attr])
                    if v > 1e10:
                        v = v // 1000
                    start_ts = v
                    break
                except:
                    pass

        match_id = re.sub(r"\W+", "_", link)
        out.append({
            "match_id": match_id,
            "name": name,
            "team1": t1,
            "team2": t2,
            "start_ts": start_ts,
            "coef1": coef1,
            "coef2": coef2,
            "link": link
        })
    # unique by id, preserve first occurrence
    uniq = {}
    for m in out:
        if m["match_id"] not in uniq:
            uniq[m["match_id"]] = m
    return list(uniq.values())

def get_cs_matches_and_cache():
    html = fetch(WINLINE_URL)
    if not html:
        return []
    matches = parse_matches(html)
    # cache to DB
    for m in matches:
        cur.execute("""
            INSERT OR REPLACE INTO matches_cache
            (match_id, name, team1, team2, start_ts, coef1, coef2, link, status)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (m["match_id"], m["name"], m["team1"], m["team2"], m["start_ts"] or 0,
              m["coef1"] or 0.0, m["coef2"] or 0.0, m["link"], "upcoming"))
    conn.commit()
    return matches

# ---------------------------
# –õ–æ–≥–∏–∫–∞ –∫–æ–º–∞–Ω–¥ –∏ –∫–æ–ª–±–µ–∫–æ–≤
# ---------------------------
def handle_start(chat_id: int, user_id: int):
    cur.execute("SELECT balance FROM users WHERE user_id=?", (user_id,))
    row = cur.fetchone()
    if not row:
        cur.execute("INSERT INTO users (user_id, balance) VALUES (?, ?)", (user_id, START_BALANCE))
        conn.commit()
        tg_send_message(chat_id, f"üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {START_BALANCE:.0f} Peek.")
    else:
        tg_send_message(chat_id, "–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /balance, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –±–∞–ª–∞–Ω—Å.")

def handle_balance(chat_id: int, user_id: int):
    cur.execute("SELECT balance FROM users WHERE user_id=?", (user_id,))
    row = cur.fetchone()
    if not row:
        tg_send_message(chat_id, "–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /start")
        return
    tg_send_message(chat_id, f"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {row[0]:.2f} Peek")

def handle_help(chat_id: int):
    txt = ("üìò –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ —Å—Ç–∞–≤–∫–∞–º:\n\n"
           "1) /matches ‚Äî –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–∞—Ç—á–µ–π Counter-Strike (–±–ª–∏–∂–∞–π—à–∞—è –Ω–µ–¥–µ–ª—è).\n"
           "2) –ù–∞–∂–∞—Ç—å –Ω–∞ –º–∞—Ç—á ‚Äî –±–æ—Ç –ø–æ–∫–∞–∂–µ—Ç –∫–æ–º–∞–Ω–¥—ã –∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã.\n"
           "3) –í—ã–±–µ—Ä–∏—Ç–µ /pick1 –∏–ª–∏ /pick2 (—á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É) ‚Äî –∑–∞—Ç–µ–º –≤–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤ Peek.\n"
           "4) –°—É–º–º–∞ —Å–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è —Å—Ä–∞–∑—É. –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –º–∞—Ç—á–∞ –±–æ—Ç —Å–æ–æ–±—â–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ –Ω–∞—á–∏—Å–ª–∏—Ç –≤—ã–∏–≥—Ä—ã—à (amount * coef) –µ—Å–ª–∏ –≤—ã —É–≥–∞–¥–∞–ª–∏.\n")
    tg_send_message(chat_id, txt)

def handle_matches(chat_id: int):
    matches = get_cs_matches_and_cache()
    if not matches:
        tg_send_message(chat_id, "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return
    kb = {"inline_keyboard": []}
    for m in matches:
        start = datetime.utcfromtimestamp(m['start_ts']).strftime("%Y-%m-%d %H:%M UTC") if m['start_ts'] else "–≤—Ä–µ–º—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        label = f"{m['team1']} / {m['team2']} ‚Äî {start}"
        kb["inline_keyboard"].append([{"text": label, "callback_data": f"match|{m['match_id']}"}])
    tg_send_message(chat_id, "–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á (Counter-Strike):", reply_markup=kb)

def handle_pick_command(chat_id: int, user_id: int, match_id: str, pick_number: int):
    # get match from cache
    cur.execute("SELECT name, team1, team2, coef1, coef2 FROM matches_cache WHERE match_id=?", (match_id,))
    row = cur.fetchone()
    if not row:
        tg_send_message(chat_id, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –º–∞—Ç—á—É –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
        return
    name, t1, t2, c1, c2 = row
    team = t1 if pick_number == 1 else t2
    coef = c1 if pick_number == 1 else c2
    # save session awaiting amount
    user_sessions[user_id] = {"stage": "await_amount", "match_id": match_id, "team": team, "coef": coef, "match_name": name}
    tg_send_message(chat_id, f"–í—ã –≤—ã–±—Ä–∞–ª–∏ <b>{team}</b> (–∫–æ—ç—Ñ {coef}). –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤ Peek (—á–∏—Å–ª–æ–º).")

# ---------------------------
# –†–∞–∑–±–æ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π –∏ callback_query –∏–∑ webhook
# ---------------------------
@app.post(WEBHOOK_PATH)
async def telegram_webhook(request: Request):
    data = await request.json()
    # message text
    if "message" in data:
        msg = data["message"]
        chat_id = msg["chat"]["id"]
        user_id = msg["from"]["id"]
        text = msg.get("text", "").strip()

        # If user expecting amount input
        session = user_sessions.get(user_id)
        if session and session.get("stage") == "await_amount" and text and re.match(r"^\d+(\.\d+)?$", text):
            amount = float(text)
            # validate balance
            cur.execute("SELECT balance FROM users WHERE user_id=?", (user_id,))
            row = cur.fetchone()
            if not row:
                tg_send_message(chat_id, "–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /start")
                user_sessions.pop(user_id, None)
                return {"ok": True}
            balance = row[0]
            if amount <= 0 or amount > balance:
                tg_send_message(chat_id, f"–ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞. –í–∞—à –±–∞–ª–∞–Ω—Å: {balance:.2f} Peek")
                return {"ok": True}
            # create bet: status pending, amount set, balance deducted
            cur.execute("INSERT INTO bets (user_id, match_id, match_name, team, amount, coef, placed_at, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                        (user_id, session["match_id"], session["match_name"], session["team"], amount, session["coef"], datetime.utcnow().isoformat(), "pending"))
            cur.execute("UPDATE users SET balance = balance - ? WHERE user_id = ?", (amount, user_id))
            conn.commit()
            tg_send_message(chat_id, f"‚úÖ –°—Ç–∞–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞: {amount:.2f} Peek –Ω–∞ {session['team']} (–∫–æ—ç—Ñ {session['coef']}). –£–¥–∞—á–∏!")
            user_sessions.pop(user_id, None)
            return {"ok": True}

        # commands
        if text == "/start":
            handle_start(chat_id, user_id)
            return {"ok": True}
        if text == "/balance":
            handle_balance(chat_id, user_id)
            return {"ok": True}
        if text == "/help":
            handle_help(chat_id)
            return {"ok": True}
        if text == "/matches":
            handle_matches(chat_id)
            return {"ok": True}
        # inline pick via typed commands like /pick1_<id> or /pick2_<id> (fallback)
        m = re.match(r"^/pick([12])_?(.+)?$", text)
        if m:
            pick_num = int(m.group(1))
            mid = m.group(2) if m.group(2) else None
            if not mid:
                tg_send_message(chat_id, "–ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ /pick. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –∏–ª–∏ /matches –∏ –∑–∞—Ç–µ–º /pick1_<id>.")
                return {"ok": True}
            handle_pick_command(chat_id, user_id, mid, pick_num)
            return {"ok": True}

        # unknown text
        tg_send_message(chat_id, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –í–≤–µ–¥–∏—Ç–µ /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.")
        return {"ok": True}

    # callback_query (–∫–Ω–æ–ø–∫–∏)
    if "callback_query" in data:
        cb = data["callback_query"]
        cid = cb["id"]
        from_id = cb["from"]["id"]
        data_str = cb.get("data", "")
        # match selection
        if data_str.startswith("match|"):
            _, mid = data_str.split("|", 1)
            # store selected match and show options pick1/pick2 as buttons
            cur.execute("SELECT name, team1, team2, coef1, coef2 FROM matches_cache WHERE match_id=?", (mid,))
            row = cur.fetchone()
            if not row:
                tg_send_message(from_id, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –º–∞—Ç—á—É –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
                tg_answer_callback(cid, "–û—à–∏–±–∫–∞")
                return {"ok": True}
            name, t1, t2, c1, c2 = row
            text = f"–í—ã –≤—ã–±—Ä–∞–ª–∏: <b>{name}</b>\n\n1) {t1} ‚Äî {c1}\n2) {t2} ‚Äî {c2}\n\n–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å:"
            kb = {"inline_keyboard": [
                [{"text": f"–ü–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ {t1}", "callback_data": f"pick|{mid}|1"}],
                [{"text": f"–ü–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ {t2}", "callback_data": f"pick|{mid}|2"}]
            ]}
            tg_send_message(from_id, text, reply_markup=kb)
            tg_answer_callback(cid)
            return {"ok": True}

        # pick from inline buttons
        if data_str.startswith("pick|"):
            _, mid, picknum = data_str.split("|", 2)
            picknum = int(picknum)
            handle_pick_command(from_id, from_id, mid, picknum)  # chat_id and user_id are same here
            tg_answer_callback(cid, "–û–ö")
            return {"ok": True}

    return {"ok": True}

# ---------------------------
# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –º–∞—Ç—á–∞ (—ç–≤—Ä–∏—Å—Ç–∏–∫–∞)
# ---------------------------
def parse_winner_from_match_page(html: str, team1: str, team2: str):
    if not html:
        return None
    text = BeautifulSoup(html, "lxml").get_text(" ", strip=True).lower()
    # look for phrases like "<team> –ø–æ–±–µ–¥–∏–ª" or "<team> win" or scores 2:0  etc.
    for team in (team1, team2):
        if not team:
            continue
        tn = team.lower()
        if tn in text:
            # check nearby words
            pattern = re.compile(re.escape(tn) + r".{0,40}(–≤—ã–∏–≥—Ä|–ø–æ–±–µ–¥|win|won|winner)", re.IGNORECASE)
            if re.search(pattern, text):
                return team
    # try score patterns
    m = re.search(r"(\d+)\s*[:\-]\s*(\d+)", text)
    if m:
        a, b = int(m.group(1)), int(m.group(2))
        if a > b:
            return team1
        if b > a:
            return team2
    return None

# ---------------------------
# –§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ ‚Äî –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏ –≤—ã–¥–∞—á–∞ –≤—ã–∏–≥—Ä—ã—à–µ–π
# ---------------------------
async def background_result_checker():
    await asyncio.sleep(5)
    while True:
        try:
            # select pending match ids (distinct)
            cur.execute("SELECT DISTINCT match_id FROM bets WHERE status='pending'")
            rows = cur.fetchall()
            if not rows:
                await asyncio.sleep(CHECK_INTERVAL)
                continue
            for (mid,) in rows:
                # load match info
                cur.execute("SELECT link, team1, team2 FROM matches_cache WHERE match_id=?", (mid,))
                info = cur.fetchone()
                if not info:
                    continue
                link, team1, team2 = info
                html = fetch(link) if link else None
                winner = parse_winner_from_match_page(html, team1, team2)
                if winner:
                    # process all pending bets for this match
                    cur.execute("SELECT id, user_id, team, amount, coef FROM bets WHERE match_id=? AND status='pending'", (mid,))
                    bets = cur.fetchall()
                    for bet_id, uid, team, amount, coef in bets:
                        if team == winner:
                            payout = amount * (coef if coef and coef > 0 else 1.0)
                            cur.execute("UPDATE users SET balance = balance + ? WHERE user_id = ?", (payout, uid))
                            cur.execute("UPDATE bets SET status='won' WHERE id=?", (bet_id,))
                            tg_send_message(uid, f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –Ω–∞ <b>{team}</b> –≤—ã–∏–≥—Ä–∞–ª–∞. –í—ã–ø–ª–∞—Ç–∞: {payout:.2f} Peek.")
                        else:
                            cur.execute("UPDATE bets SET status='lost' WHERE id=?", (bet_id,))
                            tg_send_message(uid, f"‚òπÔ∏è –í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –Ω–∞ <b>{team}</b> –ø—Ä–æ–∏–≥—Ä–∞–ª–∞.")
                    conn.commit()
                else:
                    # no winner yet, skip
                    pass
            await asyncio.sleep(CHECK_INTERVAL)
        except Exception as e:
            print("background_result_checker error:", e)
            await asyncio.sleep(CHECK_INTERVAL)

# ---------------------------
# Startup / webhook set
# ---------------------------
@app.on_event("startup")
async def startup():
    # start background checker
    asyncio.create_task(background_result_checker())
    # set webhook if WEBHOOK_FULL provided
    if WEBHOOK_FULL:
        try:
            requests.get(f"{TELEGRAM_API}/setWebhook", params={"url": WEBHOOK_FULL}, timeout=10)
            print("Webhook set to", WEBHOOK_FULL)
        except Exception as e:
            print("Error setting webhook:", e)

# ---------------------------
# Run
# ---------------------------
if __name__ == "__main__":
    # for local testing you can set WEBHOOK_BASE to http ngrok url and run this file
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT", "8000")))
